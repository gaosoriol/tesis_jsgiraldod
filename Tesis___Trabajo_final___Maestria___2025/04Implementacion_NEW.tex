\chapter{Implementación del Sistema}
\label{chap:implementacion}

% ============================================================================
% CAPÍTULO 4: IMPLEMENTACIÓN
% Este capítulo documenta los aspectos técnicos de implementación del sistema
% propuesto, incluyendo hardware, firmware, configuraciones y deployment.
% ============================================================================

\section{Introducción}
\label{sec:impl-intro}

Este capítulo presenta la implementación práctica de la arquitectura de telemetría propuesta en el Capítulo~\ref{chap:arquitectura}, detallando las especificaciones de hardware desplegado, desarrollo de firmware, configuraciones de red, y procedimientos de deployment utilizados en el piloto experimental documentado en el Capítulo~\ref{chap:resultados}.

La implementación se organizó en cuatro niveles correspondientes a la arquitectura de cuatro capas: (1) Nodos adaptadores ESP32-C6 con interfaz RS-485 a medidores, (2) DCUs (Data Concentrator Units) con radios Thread y HaLow, (3) Gateway edge con procesamiento local y uplink LTE, y (4) infraestructura cloud con ThingsBoard para gestión y analytics.

\section{Hardware Implementado}
\label{sec:impl-hardware}

\subsection{Nivel 1: Nodos Adaptadores (ESP32-C6)}
\label{sec:impl-nodos}

\subsubsection{Especificaciones Hardware Nodos}

La implementación utilizó 30 nodos adaptadores basados en ESP32-C6 (Espressif Systems) con las siguientes características técnicas:

\begin{itemize}
    \item \textbf{Procesador:} RISC-V single-core 32-bit @ 160 MHz
    \item \textbf{Memoria:} 512 KB SRAM, 4 MB Flash integrada
    \item \textbf{Conectividad:} IEEE 802.15.4 (Thread 1.3.0) + Bluetooth 5.0 LE
    \item \textbf{Interfaces:} UART × 3, SPI × 2, I2C × 1, GPIO × 22
    \item \textbf{Alimentación:} 5V regulado desde medidor (puerto auxiliar)
    \item \textbf{Consumo medido:} 19 mA RX Thread + 22 mA TX @ +4 dBm = 0.48 W promedio
\end{itemize}

% TODO: Migrar contenido detallado specs desde Cap 3

\subsection{Nivel 2: DCUs y Router de Agregación}
\label{sec:impl-dcu}

% CONTENIDO NUEVO: Router MikroTik + HaLow AP configuración
% Pendiente desarrollo según MAPA_MIGRACION (Prioridad ALTA)

\subsection{Nivel 3: Gateway Edge (Raspberry Pi 4)}
\label{sec:impl-gateway}

\subsubsection{Especificaciones Hardware Gateway}

\begin{itemize}
    \item \textbf{Plataforma:} Raspberry Pi 4 Model B (4 GB RAM)
    \item \textbf{Procesador:} Broadcom BCM2711 quad-core Cortex-A72 @ 1.5 GHz
    \item \textbf{Almacenamiento:} MicroSD 128 GB UHS-I (SanDisk Extreme Pro)
    \item \textbf{Conectividad:} Ethernet Gigabit + WiFi 802.11ac dual-band + LTE Cat-M1 USB
    \item \textbf{OS:} Ubuntu Server 22.04 LTS ARM64
\end{itemize}

% TODO: Migrar detalles Docker stack desde Cap 3 líneas ~2400-2600

\subsection{Nivel 4: Infraestructura Cloud}
\label{sec:impl-cloud}

% CONTENIDO NUEVO: ThingsBoard AWS deployment Terraform
% Pendiente desarrollo según MAPA_MIGRACION (Prioridad ALTA)

\section{Desarrollo de Firmware}
\label{sec:impl-firmware}

\subsection{Firmware Nodos ESP32-C6}
\label{sec:impl-firmware-nodos}

El firmware de los nodos adaptadores fue desarrollado utilizando ESP-IDF v5.1.2 (Espressif IoT Development Framework) con las siguientes características implementadas:

\begin{itemize}
    \item \textbf{Stack Thread:} OpenThread 1.3.0 integrado vía ESP-IDF component
    \item \textbf{Parser DLMS/COSEM:} Implementación custom para códigos OBIS estándar
    \item \textbf{Protocolo CoAP:} Cliente libcoap con soporte Confirmable/Non-Confirmable
    \item \textbf{Seguridad:} DTLS 1.2 con certificados X.509 pre-provisionados
    \item \textbf{OTA Updates:} LwM2M Object 5 (Firmware Update) con verificación SHA-256
\end{itemize}

% TODO: Migrar código snippets y explicación parser DLMS desde Cap 3

\subsubsection{Parser DLMS/COSEM}

% Contenido a migrar: implementación lectura códigos OBIS desde medidor

\subsection{Firmware DCU (OpenThread Border Router)}
\label{sec:impl-firmware-dcu}

% Contenido a migrar: configuración OTBR, wpantund, etc.

\subsection{Software Gateway}
\label{sec:impl-software-gateway}

\subsubsection{Stack Docker y Microservicios}

La arquitectura de software del Gateway implementa seis microservicios containerizados con Docker Compose, cada uno con límites de recursos y persistencia configurada:

\textbf{1. Bridge CoAP-MQTT (Traductor Protocolos):}
\begin{itemize}
    \item \textbf{Función:} Recibe mensajes CoAP desde Thread mesh (puerto UDP 5683), parsea payload LwM2M TLV, publica a Mosquitto via MQTT
    \item \textbf{Implementación:} Python 3.11 + aiocoap library
    \item \textbf{Recursos:} CPU 0.5 cores, RAM 256 MB limit
    \item \textbf{Throughput:} 1,000 msgs/s (validado stress test)
\end{itemize}

\textbf{2. Mosquitto MQTT Broker:}
\begin{itemize}
    \item \textbf{Función:} Intermediario local (broker) para buffering, QoS 1 (At Least Once), bridge a ThingsBoard cloud
    \item \textbf{Configuración:} Persistencia habilitada (disk-backed queue), max\_queued\_messages 100,000
    \item \textbf{Recursos:} CPU 1 core, RAM 512 MB
    \item \textbf{Uptime piloto:} 99.97\% (2 reinicios mantenimiento en 90 días)
\end{itemize}

\textbf{3. PostgreSQL 15 + TimescaleDB 2.13:}
\begin{itemize}
    \item \textbf{Función:} Base datos time-series con hypertables (particionamiento automático por tiempo), continuous aggregates (bins 5 min, 1h, 1d), compresión columnar 10:1
    \item \textbf{Esquema:} Tabla \texttt{telemetry} (device\_id, timestamp, voltage, current, energy, power\_factor)
    \item \textbf{Configuración:} shared\_buffers 1 GB, maintenance\_work\_mem 256 MB, checkpoint\_timeout 15 min
    \item \textbf{Retención:} 90 días datos granulares (15 min), 2 años agregados (1h bins)
    \item \textbf{Recursos:} CPU 2 cores, RAM 2 GB, storage 128 GB SD card UHS-I
\end{itemize}

\textbf{4. Apache Kafka 3.5:}
\begin{itemize}
    \item \textbf{Función:} Message queue asíncrono para eventos high-priority (alarmas, tamper), decoupling entre producers (Mosquitto) y consumers (Node-RED, TimescaleDB)
    \item \textbf{Topics:} \texttt{telemetry.raw} (100k msgs/día), \texttt{alarms.critical} (5-10 msgs/día)
    \item \textbf{Retención:} 7 días (balance storage vs replay capability)
\end{itemize}

\textbf{5. Node-RED 3.1:}
\begin{itemize}
    \item \textbf{Función:} Rule Engine visual para flujos edge processing (filtrado datos no-críticos 60\%, detección anomalías threshold-based, agregación temporal)
    \item \textbf{Flujos implementados:} 12 flows (fraud detection, voltage sag/swell detection, power factor correction alerts)
    \item \textbf{Latencia procesamiento:} 2-4 ms por mensaje
\end{itemize}

\textbf{6. Grafana 10.2:}
\begin{itemize}
    \item \textbf{Función:} Dashboards locales para operadores campo (visualización sin internet)
    \item \textbf{Datasource:} PostgreSQL + TimescaleDB queries SQL
    \item \textbf{Dashboards:} 8 dashboards (real-time telemetry, historical trends, alarm overview, device status)
    \item \textbf{Acceso:} Puerto 3000 (HTTP básico auth), no expuesto WAN
\end{itemize}

\textbf{Docker Compose resource limits (Raspberry Pi 4 4GB):}
\begin{verbatim}
services:
  bridge-coap-mqtt:
    cpus: 0.5
    mem_limit: 256m
  mosquitto:
    cpus: 1.0
    mem_limit: 512m
  postgres:
    cpus: 2.0
    mem_limit: 2048m
    volumes:
      - pgdata:/var/lib/postgresql/data
  kafka:
    cpus: 1.0
    mem_limit: 1024m
  nodered:
    cpus: 0.5
    mem_limit: 256m
  grafana:
    cpus: 0.5
    mem_limit: 256m
\end{verbatim}

\textbf{Validación piloto:} Stack Docker operó 90 días sin memory leaks (varianza RAM <5\%), CPU promedio 42\% bajo carga normal (30 medidores @ 15 min), pico 67\% stress test (60s polling).

\section{Configuración de Redes}
\label{sec:impl-redes}

\subsection{Configuración Red Thread}
\label{sec:impl-config-thread}

\subsubsection{Decisión Thread vs Zigbee}

La arquitectura seleccionó Thread 1.4.0 sobre Zigbee 3.0 tras análisis comparativo detallado evaluando 9 criterios técnicos:

\begin{table}[H]
\centering
\caption{Análisis comparativo Thread vs Zigbee para AMI}
\label{tab:impl-thread-vs-zigbee}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|c|c|p{6cm}|}
\hline
\rowcolor{gray!20}
\textbf{Criterio} & \textbf{Thread 1.4.0} & \textbf{Zigbee 3.0} & \textbf{Análisis y Justificación} \\
\hline
\textbf{IPv6 nativo E2E} & Sí & No & \textbf{Thread gana}: Direccionamiento IPv6 end-to-end elimina NAT/gateway traducción Zigbee 16-bit, reduce latencia 40-60\% \\
\hline
\textbf{IEEE 2030.5 compliance} & Directo & Gateway & Thread implementa IEEE 2030.5 nativamente, Zigbee requiere ALG (Application Layer Gateway) \\
\hline
\textbf{Latencia típica} & 50-90 ms & 100-150 ms & Thread menor latencia por IPv6 nativo y ausencia gateway traducción \\
\hline
\textbf{Consumo energético} & 5-10 mA sleep & 3-5 mA sleep & Zigbee gana, pero no crítico (nodos alimentados desde medidor 5V) \\
\hline
\textbf{Costo módulos (2024)} & \$5-8 & \$3-5 & Zigbee 40\% más económico, pero Thread elimina ALG (\$200-400 ahorro) \\
\hline
\textbf{Seguridad commissioning} & PAKE (ECC P-256) & Install Code & PAKE resiste ataques diccionario offline \\
\hline
\textbf{Ecosistema} & Emergente (Matter) & Maduro (15 años) & Thread respaldado Google, Apple, Amazon (Thread Group) \\
\hline
\end{tabular}%
}
\end{table}

\textbf{Decisión final: Thread 1.4.0}

Ventajas críticas Thread:
\begin{enumerate}
    \item \textbf{IPv6 E2E}: Elimina gateway traducción, reduce latencia 40\% (150 ms → 90 ms)
    \item \textbf{IEEE 2030.5 nativo}: Cumplimiento directo Smart Energy Profile 2.0 sin ALG
    \item \textbf{TCO equivalente}: Costo adicional módulos compensado por eliminación ALG
\end{enumerate}

\subsubsection{Parámetros Thread Network}

Configuración Thread implementada en piloto:

\begin{itemize}
    \item \textbf{PAN ID:} 0xABCD (único por deployment)
    \item \textbf{Extended PAN ID:} 0x1234567890ABCDEF
    \item \textbf{Network Name:} ``AMI-Pilot-Q4-2024''
    \item \textbf{Channel:} 25 (2.475 GHz, sin interferencia WiFi canales 1-11)
    \item \textbf{Network Key:} 128-bit AES (provisionada via BLE commissioning PAKE)
    \item \textbf{TX Power:} +4 dBm (balance alcance vs consumo)
    \item \textbf{Commissioning:} BLE + QR code scan (ECC P-256 PAKE resiste diccionario)
\end{itemize}

\textbf{Topología piloto:} 30 nodos End Devices → 1 DCU (Border Router) → Gateway. Máximo 1 hop Thread (latencia medida 8 ms). Escalado a 100 medidores requiere 2 DCUs (50 medidores c/u, límite 64 neighbors ESP32-C6).

\subsection{Configuración HaLow}
\label{sec:impl-config-halow}

% CONTENIDO NUEVO: Configuración Alfa Tube-AHM OpenWRT
% Pendiente desarrollo según MAPA_MIGRACION (Prioridad ALTA)

\subsection{Configuración LTE Cat-M1}
\label{sec:impl-config-lte}

\subsubsection{Módulo Quectel BG96}

\begin{itemize}
    \item \textbf{Operador:} Claro Colombia (APN: \texttt{internet.comcel.com.co})
    \item \textbf{Plan datos:} 50 MB/mes IoT M2M
    \item \textbf{eDRX:} Cycle 10.24 s (Power Save Mode habilitado)
    \item \textbf{PSM:} T3324 = 30 s active, T3412 = 24 h periodic TAU
\end{itemize}

% TODO: Migrar AT commands configuración desde Cap 3 líneas ~2100-2300

\section{Implementación de Seguridad}
\label{sec:impl-seguridad}

\subsection{Secure Boot ESP32-C6}

Todos los nodos fueron provisionados con Secure Boot habilitado mediante eFUSE burning:

\begin{itemize}
    \item \textbf{Bootloader signing:} RSA-2048 signature verification
    \item \textbf{Anti-rollback:} Version counter en eFUSE incrementa con cada OTA
    \item \textbf{Flash encryption:} AES-256-XTS para protección firmware at-rest
\end{itemize}

% TODO: Migrar comandos esptool.py desde materiales

\subsection{Configuración WPA3-SAE (HaLow)}

% Contenido a migrar: configuración hostapd WPA3, PSK derivation

\subsection{Certificados X.509 y PKI}

La arquitectura implementa Public Key Infrastructure (PKI) de tres niveles:

\begin{itemize}
    \item \textbf{Root CA:} Certificado raíz auto-firmado (validez 10 años)
    \item \textbf{Intermediate CA:} Certificado intermedio para firma dispositivos (validez 5 años)
    \item \textbf{Device Certificates:} Certificados únicos por nodo (validez 2 años, renovación automática)
\end{itemize}

% TODO: Migrar scripts OpenSSL generación certificados desde materiales

\subsection{Análisis de Seguridad por Capas}
\label{sec:impl-security-analysis}

La arquitectura integra múltiples controles de seguridad alineados con NIST Cybersecurity Framework 2.0, abordando 8 vectores de ataque críticos identificados mediante análisis STRIDE.

\begin{table}[H]
\centering
\caption{Matriz de Vectores de Ataque y Mitigaciones con Mapeo NIST CSF 2.0}
\label{tab:security-threats-impl}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|p{3cm}|p{1.5cm}|p{5.5cm}|p{3cm}|p{2cm}|}
\hline
\rowcolor{gray!20}
\textbf{Vector de Ataque} & \textbf{Impacto} & \textbf{Mitigación Implementada} & \textbf{Riesgo Residual} & \textbf{NIST CSF 2.0} \\
\hline
\multicolumn{5}{|c|}{\cellcolor{blue!20}\textbf{CAPA 1: NODOS THREAD}} \\
\hline
\textbf{A1: Nodo comprometido} & Crítico & Thread PAKE (ECC P-256) + Network Key rotación 90d + Secure Boot ESP32-C6 (RSA-2048) & Medio & \textbf{PR.AC-1} \\
\hline
\textbf{A2: Replay mensajes} & Alto & CoAP timestamp Unix + Message ID único. Gateway descarta delay >30s & Bajo & \textbf{PR.DS-5} \\
\hline
\textbf{A3: Tampering físico} & Alto & Reed switch apertura + alarma + log SHA-256 inmutable + caja Torx T10 & Medio & \textbf{DE.CM-7} \\
\hline
\multicolumn{5}{|c|}{\cellcolor{green!20}\textbf{CAPA 2: GATEWAY}} \\
\hline
\textbf{A4: OTBR comprometido} & Crítico & SSH dual-auth: RSA-4096 + OTP Google Auth. Root disable. Firewall nftables & Bajo & \textbf{PR.AC-4} \\
\hline
\textbf{A5: MitM HaLow} & Alto & WPA3-SAE + jamming detection SNR <10dB + channel hopping auto & Medio & \textbf{PR.DS-2} \\
\hline
\textbf{A6: Exfiltración PostgreSQL} & Crítico & LUKS AES-256-XTS at-rest + mTLS X.509 90d + RLS PostgreSQL & Bajo & \textbf{PR.DS-1} \\
\hline
\multicolumn{5}{|c|}{\cellcolor{orange!20}\textbf{CAPA 3: BACKHAUL LTE}} \\
\hline
\textbf{A7: Interceptación MQTT} & Alto & TLS 1.3 ChaCha20-Poly1305 + cert pinning SHA-256 & Bajo & \textbf{PR.DS-2} \\
\hline
\textbf{A8: Credential theft} & Alto & TPM 2.0 + MQTT rotación 30d + rate limit 5 fallos → bloqueo 1h & Bajo & \textbf{PR.AC-1} \\
\hline
\end{tabular}%
}
\end{table}

\textbf{Controles implementados por categoría NIST:}

\begin{itemize}
    \item \textbf{PR.AC (Protect Access Control):} 4 controles (A1, A4, A8, SSH dual-auth)
    \item \textbf{PR.DS (Protect Data Security):} 4 controles (A2, A5, A6, A7, cifrado E2E)
    \item \textbf{DE.CM (Detect Security Continuous Monitoring):} 1 control (A3, tamper detection)
\end{itemize}

\subsection{Configuración Firewall (nftables)}
\label{sec:impl-firewall}

Gateway implementa firewall stateful default-deny:

\begin{verbatim}
#!/usr/sbin/nft -f
flush ruleset

table inet filter {
    chain input {
        type filter hook input priority 0; policy drop;
        ct state established,related accept
        iif lo accept
        tcp dport 22 ip saddr 192.168.1.0/24 accept comment "SSH local"
        tcp dport 3000 ip saddr 192.168.1.0/24 accept comment "Grafana"
        tcp dport 8883 accept comment "MQTT/TLS ThingsBoard"
        udp dport 5683 accept comment "CoAP Thread"
        drop
    }
    chain forward {
        type filter hook forward priority 0; policy drop;
    }
    chain output {
        type filter hook output priority 0; policy accept;
    }
}
\end{verbatim}

\textbf{Puertos expuestos:} SSH (22, local only), Grafana (3000, local), MQTT/TLS (8883, cloud), CoAP (5683, Thread mesh). WAN exposure minimizado (solo MQTT/TLS egress, no ingress).

\section{Deployment y Puesta en Marcha}
\label{sec:impl-deployment}

\subsection{Procedimiento de Instalación Nodos}

El deployment de los 30 nodos en el piloto siguió el siguiente procedimiento estandarizado:

\begin{enumerate}
    \item Verificación instalación medidor Itron SL7000 (puerto RS-485 accesible)
    \item Montaje nodo ESP32-C6 en caja IP65 con tornillos Torx T10
    \item Conexión RS-485: Terminal A (RX+), Terminal B (RX-), GND común
    \item Alimentación desde puerto auxiliar medidor: 5V DC @ 100 mA
    \item Commissioning BLE: Escaneo QR code con app Android custom
    \item Provisión credenciales Thread: Network Key, PAN ID, Channel 25
    \item Verificación conectividad: ICMP ping a DCU (fe80::dcdc:dcdc:dcdc:0001)
    \item Test lectura DLMS: Código OBIS 1-0:1.8.0.255 (energía activa)
\end{enumerate}

Tiempo promedio instalación por nodo: 15 minutos (técnico experimentado).

% TODO: Expandir con fotos deployment, checklist completo

\subsection{Configuración DCU y Gateway}

% Contenido a migrar: procedimiento setup DCU, Gateway, validación end-to-end

\subsection{Troubleshooting Común}

Durante el deployment piloto se identificaron los siguientes problemas recurrentes y sus soluciones:

\begin{table}[H]
\centering
\caption{Problemas comunes durante deployment y soluciones aplicadas}
\label{tab:troubleshooting-deployment}
\begin{tabular}{|p{4cm}|p{4cm}|p{5cm}|}
\hline
\rowcolor{gray!20}
\textbf{Problema} & \textbf{Causa Raíz} & \textbf{Solución} \\
\hline
Nodo no se une a Thread & Credenciales incorrectas o Channel ocupado & Re-commissioning con app BLE, verificar Channel 25 libre \\
\hline
Lectura DLMS timeout & Cable RS-485 A/B invertido & Intercambiar terminales A↔B \\
\hline
Gateway sin uplink LTE & APN incorrecto u operador no registrado & Configurar APN Claro: \texttt{internet.comcel.com.co} \\
\hline
Pérdida paquetes HaLow & Interferencia WiFi 2.4 GHz & Cambiar canal HaLow 902→915 MHz \\
\hline
\end{tabular}
\end{table}

\section{Conclusiones del Capítulo}
\label{sec:impl-conclusiones}

Este capítulo documentó la implementación práctica de la arquitectura propuesta, cubriendo especificaciones de hardware (ESP32-C6, Raspberry Pi 4, módulos LTE), desarrollo de firmware (OpenThread, parser DLMS/COSEM, stack Docker), configuraciones de red (Thread, HaLow, LTE), implementación de controles de seguridad (Secure Boot, WPA3-SAE, PKI X.509), y procedimientos de deployment estandarizados.

La implementación piloto con 30 medidores durante 90 días (Q4 2024) validó la viabilidad técnica de la arquitectura, con resultados experimentales presentados en detalle en el Capítulo~\ref{chap:resultados}.

% Aspectos clave implementación:
% - Hardware COTS (Commercial Off-The-Shelf) reduce costos vs soluciones propietarias
% - Firmware open-source (ESP-IDF, OpenThread) facilita auditoría seguridad
% - Arquitectura containerizada (Docker) simplifica deployment y updates
% - Procedimientos deployment estandarizados permiten escalado a cientos de nodos
